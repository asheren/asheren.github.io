---
layout: post
title: 'Eulers Continued: Problems 2 and 3'
date: '2013-10-09T10:25:00.003-04:00'
author: Allison McMillan
tags:
- euler
- ruby
- becoming a developer
- learning
- math
modified_time: '2013-10-09T10:26:48.137-04:00'
blogger_id: tag:blogger.com,1999:blog-6054545261088815023.post-5040210186055676110
blogger_orig_url: http://allisonsherenmcmillan.blogspot.com/2013/10/eulers-continued-problems-2-and-3.html
---

Continuing with the Project Euler problems, here's my solution for numbers 2 and 3.<br /><br /><b>Problem 2</b><br /><br /><pre>Each new term in the Fibonacci sequence is generated by adding <br />the previous two terms. <br />By starting with 1 and 2, the first 10 terms will be:<br />1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...<br />By considering the terms in the Fibonacci sequence whose <br />values do not exceed four million, find the sum of the even-valued terms.<br /><br /></pre><br />First, here are the tests that I wrote:<br /><pre>&nbsp;</pre><pre>require 'problem2/problem2'<br /><br />describe 'solution' do <br /><br />  it "sums the first two terms to generate the third term" do<br />   expect(Problem2.fib(2)).to eq 1<br />  end<br /><br />  it "sums the even-valued terms up to the limit" do<br />    expect(Problem2.fib(4000000)).to eq 4613732<br />  end<br />end</pre><br />Similar to the tests written for the first problem, we want to check the answer and put the actual numbers in the test and then write the code so that it doesn't need a number, it just needs the argument to be noted and the argument in the code pulls the fixed number arguments from the test in order to run and pass. The Problem2 is the module and fib is the method.<br /><br />So, onto the code:<br /><pre>module Problem2<br /><br />  def self.fib(limit)<br />    arr = [] <br />    a,b = 0,1 <br />  <br />   while a &lt; limit <br />      arr &lt;&lt; a <br />      a, b = b, a + b <br />    end<br /><br />    sum = arr.select { |i| i.even? }.reduce(:+) <br />   <br />  end<br /><br />  fib(4000000) #sets the limit<br />end</pre><pre>&nbsp;</pre>To solve this problem, first, I decided to create an empty array, then I needed to put stuff in the array (that's the second line). The question gives a certain number as the limit (4000000) so while the number is under the limit, we want to push the new number onto the end of the array (<code>arr &lt;&lt; a</code>). So that create the action of what will happen. Then we need to create the formula that will produce the number (the recursion formula). And that's that part of the problem. Next, once we have the Fibonacci sequence in the array, we need to solve the second part of the problem where we find the sum of the even-valued terms. In order to find the sum, we take the array and use the select method, passing the array through a block that looks for which numbers are even, selecting those numbers and then using the reduce :+ method to add those numbers together. Finally, <code>fib(4000000) </code>sets the limit of what we are looking for to put the result.  One note about solving these problems. I've started outlining each step at the top of the problem to give myself a short roadmap to work from and then once I have the problem clarified in my mind and a roadmap worked out, I can work through each part until I find the solution and get working code.  <b>&nbsp;</b><br /><br /><b>Problem 3</b><br /><br />I include both problems in this entry because my solution to problem 3 is a bit of a cheat. But before we go there, here's the problem:<br /><br /><pre>The prime factors of 13195 are 5, 7, 13 and 29.<br />What is the largest prime factor of the number 600851475143 ?</pre><br />Here are the tests I wrote:<br /><br /><pre>require 'problem3/problem3'<br /><br />describe 'answer' do <br /><br />  it 'will have the largest prime factor for 13195' do<br />    expect(Problem3.prime(13195)).to eq 29<br />  end<br /><br />  it 'will have a largest prime factor for 600851475143' do<br />    expect(Problem3.prime(600851475143)).to eq 6857<br />  end<br />end</pre><pre>&nbsp;</pre>And here's the code:<br /><br /><pre>require 'prime'<br /><br />module Problem3<br /><br />  def self.prime(num)<br />    primes = Prime.prime_division(num)<br />    primes.last[0]<br />  end<br />end<br /></pre><br />So, there's a Ruby library called Prime which makes doing anything with prime numbers really simple. First, I required that library. The I just defined primes and used prime_division which divides the number to determine which the prime numbers are. Finally, I took the last number in the list which would be the largest number. Really simple and straight forward.