---
layout: post
title: 'Session 5: Regular Expressions'
date: '2013-11-22T11:13:00.001-05:00'
author: Allison McMillan
tags: 
modified_time: '2013-11-22T11:14:30.585-05:00'
blogger_id: tag:blogger.com,1999:blog-6054545261088815023.post-1738816125058060501
blogger_orig_url: http://allisonsherenmcmillan.blogspot.com/2013/11/session-5-regular-expressions.html
---

For those of you who don’t follow me closely on <a href="http://www.twitter.com/allie_p">twitter</a>, you may have missed that I recently wrote my first regular expression!! Now, it was a very simple one but I think regular expressions can be some of the most intimidating code. You look at this blob of symbols and weirdness and there is no chance in hell you’ll be able to interpret it until you actually do some research. The first time I saw a regular expression I literally thought, what the hell is that? And is that actually I’m supposed to be able to understand one day? And then I actually wrote one, which was awesome. BUT more awesome than writing my first regular expression was going to <a href="https://twitter.com/nellshamrell">Nell’s</a> talk on <a href="http://www.slideshare.net/NellShamrell/beneath-the-surface-rubyconf-2013">Regex’s</a>. It was mind-blowing. I think the best thing about Nell’s talk was that it was high level enough that more experienced developers in the room were really interested in what she was saying and n00bs like me understood everything she said because she stepped through regex’s slowly, clearly, and explained it amazingly well. I know that this will be a talk that I continue to look back on as I write more regex’s and gain more experience with them.<br /><br /><b>TL;DR:</b> Regular expressions explained in a comprehensible, clear way are not so scary and can be really powerful.<br /><br />First, Nell spoke about the onigmo library, which I had never even heard of before. Basically, it is onigmo that reads a regular expression and parses it into abstract syntax tree and then it compiles that into instructions. The expressions relate to a finite state machine. Breaking this down the machine is the subject, the state is the state of that machine, and finite are what the possible states are.<br /><br />When making a regex, in order to call the regex in code you set it up this way:<br /><code><br />Re = ‘/force/’<br />String = “Use the force”<br />re.match(string)<br /></code><br /><br />She then went into exactly what happens. Basically, the regex starts at the beginning of the string and it works through the string until it finds the beginning of what could be a match… in the case ‘f’ of ‘force’. Once it finds that first letter, it will work through the remaining letters to determine if there is a match and if there is one, then it’ll return that match. <br /><br />From here, the talk went into different ways you can create regex’s. For example, if there is a pipe in the phrase then a match can be one part OR the other part of a string. The example used was<code> /Y(olk|oda)/ </code>so a match would be either Yolk or Yoda. Another variation is a plus quantifier. The + at the end of a string means that you can have infinite repetitions of the last letter of the string. The example she used was <code>/No+/</code> which means a match could be “Noo”, “Nooo”, or “Noooooooooooo”. There are also lazy quantifiers, star quantifiers, possessive quantifiers which she shows using a bunch of cool examples.<br /><br />Then, and this part was just really fascinating, she brought it together using an example of a challenge sent out by Avdi a little while ago. The challenge was to make a snake_case into a CamelCase using a regex. Now, beyond just showing us that, she TDD’ed it!!! I had absolutely no idea how you’d TDD a regex (or that you even could) so that was great to walk through. She started by mapping out what needed to be done and then going to it. To give an example of picking apart a regex she did this:<br /><code><br />Def upcase_chars(string)<br />Re = /\A_?[a-z] /<br />String.gsub(re){|char| char.upcase}<br /></code><br /><br />Which means: \A anchors the expression to the beginning of the string<br />_ is the underscore<br />? means that the underscore is optional (it will match the string with or without the underscore)<br />[a-z] matches any letters and not the underscore<br />and then the next line says for the string, substitute the characters for uppercase characters.<br /><br />This regex continued to get more complex for the next few minutes including a look back, figuring out some additional complications based on the underscore, and then combining the methods to create the solution.<br /><br />You can check out the final code and final specs <a href="https://github.com/nellshamrell/snake_to_camel_case">here</a> (which I highly recommend doing).<br /><br />At the end she made some final recommendations for building regular expressions. First, develop regex’s in small pieces and the combine them. Second, use <a href="http://rubular.com/">Rubular</a> and make a permalink of it. This way you can put the permalink into the code as a comment! Last, don’t be afraid of regular expressions.<br />