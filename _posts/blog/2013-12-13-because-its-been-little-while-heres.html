---
layout: post
title: Because it's been a little while... Here's another Euler!
date: '2013-12-13T12:14:00.001-05:00'
author: Allison McMillan
tags:
- testing
- euler
- ruby
- math
modified_time: '2013-12-13T12:14:38.551-05:00'
blogger_id: tag:blogger.com,1999:blog-6054545261088815023.post-1847803609033062367
blogger_orig_url: http://allisonsherenmcmillan.blogspot.com/2013/12/because-its-been-little-while-heres.html
---

Project Eulers 7 and 8<br /><br />Just a few more Euler’s left and I realized the other day how long it had been since I’d posted some answers! I’m also posting both 7 and 8 because really, problem 7 uses the prime library again, so the answer is really short and sweet.<br /><br />So, first, here is the problem:<br /><code> By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13,  we can see that the 6th prime is 13.<br /><br />What is the 10 001st prime number?</code><br /><br />First, here are the tests:<br /><br /><pre>require 'problem7/problem7'<br /><br />describe 'Prime number positions' do <br />  <br />  it "is the 6th prime number" do <br />    expect(Problem7.prime_place(6)).to eq 13<br />  end<br /><br />  it "is the 10001st prime number" do<br />    expect(Problem7.prime_place(10001)).to eq 104743<br />  end<br /><br />end<br /></pre><br />The tests and the code are pretty simple. You’re just using the resources in the prime library and then use the library to list (take) the numbers up until a certain position (ie- the 10,001st position) and then put the last number which is the answer to the question. So, here’s the code:<br /><pre>require 'prime'<br /><br />module Problem7<br /><br />        def self.prime_place(position)<br />          prime_place = Prime.take(position).last<br />        end<br /><br />  puts Prime.take(10001).last<br /><br />end<br /></pre><br /><br />And now for Euler 8. This problem was actually really tough for me for two reasons… first, it seemed different than most of the others I had done up until now and second, how the heck do you test this thing?!<br /><br />Here’s the problem:<br /><pre> Find the greatest product of five consecutive digits in the 1000-digit number.<br /><br /> 73167176531330624919225119674426574742355349194934<br /> 96983520312774506326239578318016984801869478851843<br /> 85861560789112949495459501737958331952853208805511<br /> 12540698747158523863050715693290963295227443043557<br /> 66896648950445244523161731856403098711121722383113<br /> 62229893423380308135336276614282806444486645238749<br /> 30358907296290491560440772390713810515859307960866<br /> 70172427121883998797908792274921901699720888093776<br /> 65727333001053367881220235421809751254540594752243<br /> 52584907711670556013604839586446706324415722155397<br /> 53697817977846174064955149290862569321978468622482<br /> 83972241375657056057490261407972968652414535100474<br /> 82166370484403199890008895243450658541227588666881<br /> 16427171479924442928230863465674813919123162824586<br /> 17866458359124566529476545682848912883142607690042<br /> 24219022671055626321111109370544217506941658960408<br /> 07198403850962455444362981230987879927244284909188<br /> 84580156166097919133875499200524063689912560717606<br /> 05886116467109405077541002256983155200055935729725 <br /> 71636269561882670428252483600823257530420752963450<br /></pre><br />So, first for the test. After asking around a bit, the best suggestion I got for testing was to break down the string and take 10 or 15 characters and figure out the largest product from that string and then do the same with the larger number.<br /><br />Here are the tests:<br /><pre>require 'problem8/problem8'<br /><br />describe 'largest products of consecutive numbers' do <br />  it "is the largest product of 5 consective numbers" do <br />    expect(Problem8.product(7316717653)).to eq 1764<br />  end<br /><br />  it "is the largest product of 5 consecutive numbers" do <br />    expect(Problem8.product(7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450)).to eq 40824<br />  end<br />end<br /></pre><br />And so, here’s the solution. First, I created an empty array. Then I wanted to use <code>.each_cons</code> which takes every set of consecutive numbers based on the number of characters you ask for (in this case, it would be 5 because I’m looking for the largest product of 5 consecutive numbers) but <code>.each_cons</code> wouldn’t work because you can’t call <code>.each_cons</code> on a string. So, first, I had to separate the string into individual characters by using <code>each_char</code>. Once the string was separated into <code>each_char</code> (each character) I used the map method to make each of the string characters into an array of integers. Then, I used <code>each_cons(5)</code> which separated the array of integers into arrays of every five characters. The I took the product of each of those integers and pushed it into an array. Finally, the max is called on that array which gives the largest number needed for the answer.<br /><pre>module Problem8<br />  <br />  def self.product<br />    arr = []<br /><br />    "731671765313306249192251196744265747423553491949349698352"\<br />    "0312774506326239578318016984801869478851843858615607891129"\<br />    "4949545950173795833195285320880551112540698747158523863050"\<br />    "7156932909632952274430435576689664895044524452316173185640"\<br />    "3098711121722383113622298934233803081353362766142828064444"\<br />    "8664523874930358907296290491560440772390713810515859307960"\<br />    "8667017242712188399879790879227492190169972088809377665727"\<br />    "3330010533678812202354218097512545405947522435258490771167"\<br />    "0556013604839586446706324415722155397536978179778461740649"\<br />    "5514929086256932197846862248283972241375657056057490261407"\<br />    "9729686524145351004748216637048440319989000889524345065854"\<br />    "1227588666881164271714799244429282308634656748139191231628"\<br />    "2458617866458359124566529476545682848912883142607690042242"\<br />    "1902267105562632111110937054421750694165896040807198403850"\<br />    "9624554443629812309878799272442849091888458015616609791913"\<br />    "3875499200524063689912560717606058861164671094050775410022"\<br />    "5698315520005593572972571636269561882670428252483600823257"\<br />    "530420752963450".each_char.map(&:to_i).each_cons(5) { |a| p arr << a.reduce(:*) }     <br />    puts arr.max <br />  end<br />end<br /></pre><br />Phew! Look forward to the last two Eulers, 9 and 10, which I’ll hopefully get to post soon.<br />