---
layout: post
title: More Bot Bits
date: '2013-12-26T12:08:00.002-05:00'
author: Allison McMillan
tags:
- databases
- ruby
- bot
modified_time: '2013-12-26T12:08:34.704-05:00'
blogger_id: tag:blogger.com,1999:blog-6054545261088815023.post-6326275385323449590
blogger_orig_url: http://allisonsherenmcmillan.blogspot.com/2013/12/more-bot-bits.html
---

The final component of bot functionality was setting up the database. This was really the thing that I wanted to gain some experience with and by setting up a database not in a rails application, I was able to understand some of the components a bit better. For my purposes, this database would be used to keep track of points. Often times, people will award other people points based on funny or interesting things they post. They’ll also subtract points for things but in the past, we’ve had no way to keep track of this. This bot added the following functionality: adding and subtracting points, telling a user what their score is when they ask, and printing out the leaderboard when asked.<br /><br />First, Chris and I chose a database. We decided to go with <a href="https://github.com/jeremyevans/sequel">Sequel</a> because it looked pretty interesting and simple to set up. I set up the connection first that created the database but then moved that into a separate file. This way I have the option to run the create table script only when I want to create a new database table. Then I set the database connection as a global constant like this <code>DB = Sequel.connect('sqlite://bot.rb')</code> to get things going and set out to write the related methods.<br /><br />The first method looks to see if a nickname is already in the database or if we need to add it and acts on that. <br /><br /><pre>def nick_id(nick) <br />  set = score.where(:nick =&gt; nick)&nbsp;</pre><pre>  if set.empty?<br />    nil <br />  else<br />    set.first[:id] <br />  end<br />end<br /></pre><br />So, we set the variable set which find the list of every score that has the nickname nick (nick being whatever the person’s nickname is). Then, if it doesn’t find anything, then it will return nil. Otherwise, the methods grabs the id of the first matching nick it finds with that name and returns it.<br /><br />The second method inserts or updates the score. <br /><br /><pre>def insert_or_update_score(nick, points)<br />  nick.downcase!<br />  if nick_id(nick)<br />    row = score.where(:id =&gt; nick_id(nick)).first<br />    updated_points = row[:points] + points     &nbsp;</pre><pre>    score.where(:id =&gt; nick_id(nick)).update(:points =&gt; updated_points)<br />  else<br />    score.insert(:nick =&gt; nick, :points =&gt; points) <br />  end<br />end<br /></pre><br />So, first I need to make sure all the nicks are being evaluated in the same way. I discovered this when testing and found that two different nicks would be saved in the database based on if they were capitalized or not. Then, this method needs to fetch a record, then increment the number and then save it back. If there is no nick, then it creates the new nick in the database and gives it points.<br /><br />Finally, I wanted to be able to lookup the score and if someone has no points then the method throws an exception. <br /><br /><pre>def lookup_score(nick)<br />  score.filter(:nick =&gt; nick).first[:points] <br />rescue <br />  nil<br />end<br /></pre><br />I added a rescue so if there are any exceptions, the rescue catches the exception and returns nil. Chris warned me that when looking at future projects, the rescue option can be dangerous because it can hide serious errors but for our purposes, using rescue is perfectly acceptable. <br /><br />THEN WE REFACTORED!<br />Setting the database connection as a global constant is not a good idea and having all of these methods in the main file just make it messy and unorganized. First, I changed the database connection to an instance variable by putting it into a singleton class and initializing it.<br /><br /><pre>require 'singleton'<br /><br />class DB<br />  include Singleton<br />  <br />  def initialize(file = 'sqlite://bot.db')<br />    @db = Sequel.connect(file)  #setup the DB connection<br />  end<br /></pre><br />This meant that I also had to change all of the <code>DB[:score]</code> instances in the code because it was now <code>@db</code>. Then, instead of just putting @db in each place, I extracted it into a method that does it for us.<br /><br /><pre>def score<br />  @db[:score]<br />end<br /></pre><br />And that is how I set up the bot’s database.