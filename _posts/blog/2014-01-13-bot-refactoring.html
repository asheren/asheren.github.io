---
layout: post
title: Bot Refactoring
date: '2014-01-13T09:20:00.000-05:00'
author: Allison McMillan
tags:
- refactoring
- ruby
- becoming a developer
- bot
modified_time: '2014-01-13T09:20:19.012-05:00'
blogger_id: tag:blogger.com,1999:blog-6054545261088815023.post-762104092564526015
blogger_orig_url: http://allisonsherenmcmillan.blogspot.com/2014/01/bot-refactoring.html
---

When something is built, it’s never fully done. A application without bugs doesn’t exists and once you release something into the world, there are always issues that come up and ways to make the code better. Releasing the bot into the irc channel brought to the surface a few issues that I’m working on. For example, the bot awards points not just to nicknames but to any word that comes after a number with a + or – symbol in front of it. I’ve also had to change a few regular expressions to make them more specific.<br /><br />One of the main things I started working on once the initial bot was out was refactoring. Refactoring is important. It’s a way of going back into your code, cleaning it up, making it easier to understand and more transparent. Refactoring also helps to DRY out code, meaning that you look at your code to see when and how you repeat yourself and take out that repetition. <br /><br />In the bot, there are two main places to refactor based on methods that are called often. For a majority of the functions, I provided an array of responses or gifs as a variable. I then called <code>m.reply variable.sample</code>. So instead of continuing to write this over and over again, I turned these actions into a method.<br /><br />The method looks like this:<br /><pre>def reply_random(m, list)<br />  m.reply list.sample<br />end <br /></pre>This is pretty easy to read but basically, the list is the array and so the method is to give a random reply based on the list given and replying with a random response from that list.<br /><br />This is what a corresponding function now looks like:<br /><pre>  on :message, /.*(coffee).*/i do |m|<br />    reply_random m, [<br />      "http://wac.9ebf.edgecastcdn.net/809EBF/ec-origin.chicago.barstoolsports.com/files/2012/12/badcoffee.gif",<br />      "http://thoughtcatalog.files.wordpress.com/2013/08/tumblr_ln3pef2aly1qaq98ro1_400.gif",<br />     "http://25.media.tumblr.com/57acd60ebc217bc00169fd73b52be5a6/tumblr_mi5u4eeJZv1qcwyxho1_500.gif",<br />      "https://encrypted-tbn2.gstatic.com/images?q=tbn:ANd9GcSP8TfZHYrpS1Hz2jM_vdwOToNN949vYDPFZ74G3vw41r4rNH6k",<br />      "COOOFFFEEEEE!",<br />    ]<br />  end<br /></pre><br />The second method I created to DRY out the code was the second most common functionality. This is where there is an array of response that are either replies or actions and instead of writing out the whole process (as explained in this post about <a href="http://allisonsherenmcmillan.blogspot.com/2013/12/look-what-my-bot-can-do-bot.html">bot functionality</a>) I created an action or reply response method, which operates similarly to the <code>reply_random</code> method above.<br /><br /><pre>def action_or_reply_response(m, list) <br />  list = list.sample    <br />    if list.first == :action     <br />      m.channel.action list.last <br />    else<br />      m.reply list.last  <br />    end <br />end<br /></pre><br />and again, with this change, this is what the code looks like:<br /><pre>  on :message, /.*morning.*/ do |m|<br />     action_or_reply_response m, [<br />      [:reply, "Good morning to you too!"],<br />      [:reply, "it's a brand new day!"],<br />      [:reply, "I'm sleepy today"],<br />      [:reply, "http://gifrific.com/wp-content/uploads/2012/04/bunny-sleep-work.gif"],<br />      [:action, "yawns"],<br />      [:action, "makes coffee"],<br />      [:action, "*throws open all the windows* it's a glorious day today"]<br />    ]<br />  end<br /></pre>