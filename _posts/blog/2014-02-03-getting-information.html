---
layout: post
title: Getting the Information
date: '2014-02-03T09:55:00.000-05:00'
author: Allison McMillan
tags:
- ruby
- becoming a developer
- gem
modified_time: '2014-02-03T09:55:33.658-05:00'
blogger_id: tag:blogger.com,1999:blog-6054545261088815023.post-154382786601855885
blogger_orig_url: http://allisonsherenmcmillan.blogspot.com/2014/02/getting-information.html
---

In order to actually get the information on the action campaigns that I needed, I needed to use nokogiri to parse the information, create new actions and clients, and then map that information. I started with this code:<br /><pre># def self.fetch<br />   #Nokogiri::XML(SalsaLabs::Client.new.request_data('/api/getObjects.sjs', object: 'Action')).css('item').map do |attributes|<br />   #SalsaLabs::Action.new({title: atributes.css('Title').text)})<br />   #end<br />#end<br /></pre>And then used that code to break it into smaller, more transparent methods. I broke the code into five separate methods. First, I created a new class for it called ActionFetch. Then I initialized (or set up) that class setting an instance variable for <code> api_client</code><br /><pre>def initialize(api_client)<br />  @api_client = api_client<br />end<br /></pre>Then, starting from the meat of the class, I created this method:<br /><pre>def data_request<br />  return @data if @data <br />  body = @api_client.fetch('/api/getObjects.sjs', object: 'Action') <br />  doc = Nokogiri::XML(body) <br />  @data = doc.css('item') <br />  @data<br />end<br /></pre>The data request method starts by saying if there is anything already in the @data instance variable, then just return, if not, then go through the rest of the method’s steps. This is also called Memoizing which basically means storing a value for future use so that you don’t have to run the call over again which saves you time.<br /><br />The next line says that take the api client (which is the actual http request, set up with faraday, using credentials, etc., set up in a different api client class) and get the stuff that is located at that api endpoint with the params of the object which is named Action. Then, use nokogiri to parse the information that is in the body string (set above). Finally, look at the doc (which is the result of the nokogiri parsing and is now an xml doc) and use the css selector to find all the items. Finally, return the value.<br /><br />Then, I took those results and fed them into the <code>get_results</code> method.<br /><pre>def get_results<br />  data_request.map do |attribute_set| <br />    new_action(extract_attributes(attribute_set)) <br />  end<br />end<br /></pre>This method takes the results from data_request and for each one (each attribute set), it extracts them into a hash and then makes each of them a new action (it wraps each of the attributes sets in an action class). It does this by using the <code>extract_attributes</code> method which looks like this:<br /><pre>def extract_attributes(action_data)<br />  action_data.children.inject({}) do |memo, node|<br />    memo[node.name.downcase] = node.text <br />    memo<br />  end<br />end<br /></pre>and takes each of the item nodes (action_data is the Nokogiri item tag) and makes them into a hash. And finally, wrapping it in an action class is done by using the <code>new_action</code> method which looks like this:<br /><pre>def new_action(params)<br />  SalsaLabs::Action.new(params)<br />end<br /></pre>It just stick each of the params into an object called action which gives the attributes pretty names. <br />Phew!<br /><br />Okay, so then, what do I mean by pretty names? Well, in order to see that, I look at the Action class which I’ll cover in the next post.