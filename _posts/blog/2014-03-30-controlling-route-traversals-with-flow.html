---
layout: post
title: Controlling Route Traversals with Flow
date: '2014-03-30T22:28:00.000-04:00'
author: Allison McMillan
tags:
- emberconf 2014
- UML
- learning
- ember
modified_time: '2014-03-30T22:28:00.771-04:00'
blogger_id: tag:blogger.com,1999:blog-6054545261088815023.post-7559874804966711957
blogger_orig_url: http://allisonsherenmcmillan.blogspot.com/2014/03/controlling-route-traversals-with-flow.html
---

<br /><a href="https://www.dropbox.com/s/02peoxevqwjz1bu/Controlling%20Route%20Traversal.pdf">This talk</a> was all about routes. <a href="https://twitter.com/nathanhammond">Nathan Hammond</a> started by talking about URLs in three different categories… resources, actions, and flows. Resources don’t change the state of an app and are available all the time. We want them to be in our history stack. Finally, they are plural or singular nouns depending on the controller. Actions are things like post or put paths like <code>/login </code>or <code>/recover-password</code>. It receives all the users input at once. It results in the user being presented with flash or a new resource. Finally, it should always contain a verb (see the examples from a few sentences ago). Finally, there are flows. Slows are series of actions across routes. Flows lead to a completed application state.<br /><br />A state machine allows you to jump into the flow. BUT designing a flow is really hard. You need to make sure you cover every components of the flow. There is a four step process to do this.<br />Step 1: inventory our routes in the routers<br />Step 2: list linear paths (ie- login flow traversal path)<br />Step 3: convert to node graphs<br />Step 4: identify state change to traverse each path<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Then you do a complete enumeration of the state or if you’re passing in a wait<br />Step 5: Identify backwards traversals (ie- where does the back button lead to each time you press it).<br /><br />The CS term for doing this is a directed graph. <br /><br />The result is a state machine that describes exactly how a user moves through and app. It is the picture that shows ALL of the steps we just outlined.<br /><br />Looking at this demo, <a href="http://alexdiliberto.com/emberconf-2014-demo/#/login">http://alexdiliberto.com/emberconf-2014-demo/#/login</a>, gives us a sense of flows. To “code the flow”, the general strategy is that you start by loading the session state. The you reset the controller (if needed). After, you delegate identification of where you’ll go next. Then you traverse the longest route so you know you visited every node. AND you can use <code>replaceWith</code> instead of <code>transitionTo</code> which Nathan thinks is awesome.<br /><br />A better strategy is to start with one place that defines flow and load the flow and flow state (explained as where the user is and what state they’re in). Then, you delegate the id of where to go to in the flow. After, you call back into the flow to progress. You start with a definition file with an edge list that dictates a from and a to path with conditions. The conditions are what needs to be checked, like ‘isAuthenticated’. Then you inject the flow logic. <code>beforeModel</code> looks up the current flow and identifies where the user should be and then you set the action. The action will include var Flow. Which sets state on the flow inside your routes so there’s no processing of that information in the route. Or further reading, check out ember-flows which is almost ready: <a href="https://github.com/nathanhammond/ember-flows">https://github.com/nathanhammond/ember-flows</a>.