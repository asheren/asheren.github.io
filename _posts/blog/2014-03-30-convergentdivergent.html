---
layout: post
title: Convergent/Divergent
date: '2014-03-30T19:51:00.003-04:00'
author: Allison McMillan
tags:
- emberconf 2014
- learning
- ember
- math
modified_time: '2014-03-30T20:01:07.776-04:00'
blogger_id: tag:blogger.com,1999:blog-6054545261088815023.post-8503575736295700663
blogger_orig_url: http://allisonsherenmcmillan.blogspot.com/2014/03/convergentdivergent.html
---

<br /><a href="https://speakerdeck.com/cmeiklejohn/divergent">This talk</a> was crazy. It was really academically intense and while I was able to follow the basic ideas, there was a lot of important information and concepts that were ran through really quickly. Fortunately, it seemed like most of the conference participants also thought this talk was also presented really quickly, so I wasn’t alone on this.  Also, every time I went to write a note, I feel like I missed the next two points and came back into the conversation on the third, so hopefully those notes don’t seem really disjointed. I will say that <a href="http://www.twitter.com/cmeik">Chris</a> seems like a really smart, nice dude so it’s definitely worth connecting with him for more details on this if you want to dive into it more.<br /><br />There are distributed computing issues and you’re building a distributed system. Basically, if you’re pushing state to the client, it means you’re caching validations which can lead to consistent data issues and more. This is an issue regardless of the database you’re using and this fact means you’re building a distributed system.<br /><br />Some of the main issues are dropped messages, rendered messages, race conditions, partial failures, and custom merges.  There are <a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/2012/EECS-2012-40.html">TCP incast</a>, <a href="http://en.wikipedia.org/wiki/Slow-start">TCP slow-start</a>, and <a href="http://en.wikipedia.org/wiki/Nagle%27s_algorithm">Nagle’s algorithm</a>… these are cases of latency spikes… I think.<br /><br />Then he went a little into distributed systems theory and consistency. Consistency is a contract and if developers follow the contract then there will be predictability. There are three kinds of consistency. Strict linearizable which is the total order of all events in a system and for single servers. Then there’s eventual consistency which means you eventually see all the events. It is a weaker form of consistency. Finally, there’s causal consistency which is basically, I observe an update immediately but another person may see the change a little later. When dealing with consistency, it comes down to safety vs. liveness. <br /><br />You need consensus to deal with consistency. For consensus, you’re basically looking at termination, agreement, and validity. Termination means eventually the info will show. Agreement means it will all have the same value. Validity is that the value will be part of consensus. It comes down to a generals problem which are academic concepts. There’s <a href="http://en.wikipedia.org/wiki/Two_Generals%27_Problem">two generals</a> or the Byzantine generals. There are algorithms used to solve this. Some of those algorithms are <a href="http://en.wikipedia.org/wiki/Paxos_(computer_science)">paxos</a>, <a href="http://raftconsensus.github.io/">raft</a>, <a href="http://en.wikipedia.org/wiki/Two-phase_commit_protocol">2pc</a>, and <a href="http://en.wikipedia.org/wiki/Three-phase_commit_protocol">3pc</a>.<br /><br />I’m not sure how this lead into vector clocks but then we discussed vector clocks whick allow us to define all possible orderings in a system. There are also dotted version vectors which are things having to do with events and actors.<br /><br />We then went into CRDTs. CRDTs are conflict free replicated data types. These are data structures that store something. There are two types of CRDTs: state based and operations based. State based CRDTs have monotonicity which means functions where as inputs increase, outputs increase. We care about associativity (which is a binary operation… addition is associative), community (also a binary function, addition is also commutable), and idempotence (also a binary function). All three of those exist in programming.<br /><br />If that wasn’t quite enough for you, we then spoke about bounded join semilattices… which is another math term, but this one has a decent diagram in the slides so check that out.<br /><br />So, why is all of this important? Because consensus is hard. We want to avoid coordination so the system can progress and we want a weak consistency and higher availability. The conclusion is that you’re building a distributed system so you need to be thinking about this.